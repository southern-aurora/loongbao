import{_ as s,c as i,o as a,V as t}from"./chunks/framework.ajfdQ9vp.js";const E=JSON.parse('{"title":"Router 路由","description":"","frontmatter":{},"headers":[],"relativePath":"old/docs/router.md","filePath":"old/docs/router.md"}'),e={name:"old/docs/router.md"},l=t(`<h1 id="router-路由" tabindex="-1">Router 路由 <a class="header-anchor" href="#router-路由" aria-label="Permalink to &quot;Router 路由&quot;">​</a></h1><p>路由，用于根据路径决定所具体执行的 API。</p><p>在 <a href="/loongbao/old/docs/install.html">Install</a> 章节中，您可能已经体验到了路由的&quot;魔法&quot;。在 Loongbao 中，您几乎不需要亲自编写路由的代码。Loongbao 会自动查找位于/src/app 目录下名为 api.ts 的文件，并为您自动生成路由。</p><p>假设您编写了一个<a href="/loongbao/old/docs/api.html">API</a>文件，在该文件中包含一个名为<code>helloWorld</code>的方法，其路径为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>/src/app/foo/bar/api.ts</span></span></code></pre></div><p>此时，只需访问 <code>http://localhost:9000/foo/bar/hello-world</code>，即可执行该 API。</p><h2 id="补充路由逻辑" tabindex="-1">补充路由逻辑 <a class="header-anchor" href="#补充路由逻辑" aria-label="Permalink to &quot;补充路由逻辑&quot;">​</a></h2><p>在几乎所有情况下，您应该使用 Loongbao 为您自动生成的路由。只有在特殊情况下，您才需要自定义您的路由。此时，您可以编辑 <code>/src/router.ts</code> 文件。其内容类似如下这样：</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> apiValidator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;../generate/products/api-validator&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> routerHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fullurl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> keyof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> apiValidator)[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;params&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>您可以编辑此方法的内容，以补充 Loongbao 自动生成的路由之外的期望路由匹配逻辑。您可以通过<code>return</code>返回一个已存在的 API 地址，它将被调用。如果您返回<code>false</code>，将返回一个 &quot;not-found&quot; 的失败信息。</p><p>同时，此方法接受两个参数：<code>path</code> 和 <code>fullurl</code>。<code>path</code> 表示请求路径的后缀（删除了域名和 <a href="/loongbao/old/docs/config-framework.html#ignorepathlevel">忽略的路径层级</a>），出于性能考虑，如果 URL 中包含参数，这些参数不会被删除，仍然保留在 <code>path</code> 中，例如 <code>foo/bar?hello=world</code>。<code>fullurl</code> 是完整的 URL 对象，<a href="/loongbao/old/docs/config-framework.html#ignorepathlevel">忽略的路径层级</a> 不会被删除。</p><p>请注意，此方法的优先级永远低于 Loongbao 自动生成的路由，这意味着您无法禁止某个 API 的访问。这样设计的目的是为了确保您尽量只在此处编写路由匹配规则。如果您需要对某个 API 进行授权才能访问，请使用 <a href="/loongbao/old/docs/middleware.html">中间件</a> 功能。如果您需要禁止直接调用某个 API 本身，而通过此处编写的匹配规则仍然可以间接访问该 API，请在 API 本身的代码中编写判断逻辑，并在适当的位置使其失败并返回 &quot;not-found&quot;。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineFail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;not-found&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div>`,13),n=[l];function h(p,o,k,r,d,c){return a(),i("div",null,n)}const u=s(e,[["render",h]]);export{E as __pageData,u as default};
