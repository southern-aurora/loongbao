import{_ as s,c as i,o as a,V as e}from"./chunks/framework.ajfdQ9vp.js";const g=JSON.parse('{"title":"CacheResult","description":"","frontmatter":{"title":"CacheResult"},"headers":[],"relativePath":"old/docs/cache-result.md","filePath":"old/docs/cache-result.md"}'),t={name:"old/docs/cache-result.md"},h=e(`<h1 id="结果缓存" tabindex="-1">结果缓存 <a class="header-anchor" href="#结果缓存" aria-label="Permalink to &quot;结果缓存&quot;">​</a></h1><p>当应用程序面临较高的并发压力时，通过缓存方法的结果可以有效减轻压力。我们可以优先从缓存中获取结果，以避免重复计算或查询数据库等耗时操作。这种结果缓存的机制能够提升应用程序的整体吞吐量，为用户提供更高效的服务。例如，我们可以缓存 SQL 查询的结果，或者缓存一些耗时的计算，以减少重复工作并加快响应速度。</p><h2 id="配置" tabindex="-1">配置 <a class="header-anchor" href="#配置" aria-label="Permalink to &quot;配置&quot;">​</a></h2><p>请确保您已正确配置 Redis，详情请参考上一篇关于<a href="/loongbao/old/docs/cache.html">缓存</a>的章节。</p><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><p>请传递键名、缓存过期时间、缓存的实际过期时间以及方法作为参数。在缓存未过期之前，方法将不会被重复执行，而是从缓存中获取结果。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineResultCache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;your-key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> now</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  await</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolve, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// sleep for 1 second</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="细节" tabindex="-1">细节 <a class="header-anchor" href="#细节" aria-label="Permalink to &quot;细节&quot;">​</a></h2><p>当执行 <code>defineResultCache</code> 代码时，若缓存未过期，则从缓存中读取结果。如果缓存过期，则会运行方法获取结果，并重新缓存起来。</p><p>为了减少缓存雪崩的概率，您需要设置两个过期时间：<code>TTL</code> 和 <code>realTTL</code>。</p><p>当 <code>TTL</code> 未过期时，进入正常缓存阶段，所有结果都来自缓存。</p><p>当 <code>TTL</code> 过期后，进入缓存过期阶段，此时 Loongbao 允许执行一个请求重新计算结果。</p><p>在重新计算阶段期间，其他请求仍获取旧的缓存数据，直到重新计算阶段结束并更新缓存，回到正常缓存阶段。</p><p>重新计算有可能失败，导致回到缓存过期阶段。下一个到达的请求将重新进入重新计算阶段。默认情况下，重新计算阶段持续 6 秒。若超过此时间，则认为重新计算失败。可以通过 <code>options.realGetInterval</code> 修改超时时间。</p><p>若在相当一段时间内没有请求获取结果，或持续获取失败，直到达到 <code>TTL + realTTL</code> 的过期时间后，缓存结果将被彻底删除。</p><h2 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h2><ul><li><p><code>key: string</code>: 缓存的键</p></li><li><p><code>TTL: number</code>: 缓存过期的秒数</p></li><li><p><code>realTTL: number</code>: 缓存过期后，距离真实删除缓存的秒数</p></li><li><p><code>fn: Function</code>: 要缓存的方法</p></li><li><p><code>options: { realGetInterval?: number; }</code>: 选项</p></li></ul>`,17),l=[h];function n(p,k,d,r,o,c){return a(),i("div",null,l)}const y=s(t,[["render",n]]);export{g as __pageData,y as default};
