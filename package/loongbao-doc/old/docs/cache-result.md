---
title: CacheResult
---

# 结果缓存

当应用程序面临较高的并发压力时，通过缓存方法的结果可以有效减轻压力。我们可以优先从缓存中获取结果，以避免重复计算或查询数据库等耗时操作。这种结果缓存的机制能够提升应用程序的整体吞吐量，为用户提供更高效的服务。例如，我们可以缓存 SQL 查询的结果，或者缓存一些耗时的计算，以减少重复工作并加快响应速度。

## 配置

请确保您已正确配置 Redis，详情请参考上一篇关于[缓存](/old/docs/cache.md)的章节。

## 示例

请传递键名、缓存过期时间、缓存的实际过期时间以及方法作为参数。在缓存未过期之前，方法将不会被重复执行，而是从缓存中获取结果。

```ts
const result = defineResultCache("your-key", 60, 60, async () => {
  const now = new Date().getTime();
  await new Promise((resolve) => setTimeout(resolve, 1000)); // sleep for 1 second
  return now;
});
```

## 细节

当执行 `defineResultCache` 代码时，若缓存未过期，则从缓存中读取结果。如果缓存过期，则会运行方法获取结果，并重新缓存起来。

为了减少缓存雪崩的概率，您需要设置两个过期时间：`TTL` 和 `realTTL`。

当 `TTL` 未过期时，进入正常缓存阶段，所有结果都来自缓存。

当 `TTL` 过期后，进入缓存过期阶段，此时 Loongbao 允许执行一个请求重新计算结果。

在重新计算阶段期间，其他请求仍获取旧的缓存数据，直到重新计算阶段结束并更新缓存，回到正常缓存阶段。

重新计算有可能失败，导致回到缓存过期阶段。下一个到达的请求将重新进入重新计算阶段。默认情况下，重新计算阶段持续 6 秒。若超过此时间，则认为重新计算失败。可以通过 `options.realGetInterval` 修改超时时间。

若在相当一段时间内没有请求获取结果，或持续获取失败，直到达到 `TTL + realTTL` 的过期时间后，缓存结果将被彻底删除。

## 参数

- `key: string`: 缓存的键

- `TTL: number`: 缓存过期的秒数

- `realTTL: number`: 缓存过期后，距离真实删除缓存的秒数

- `fn: Function`: 要缓存的方法

- `options: { realGetInterval?: number; }`: 选项
